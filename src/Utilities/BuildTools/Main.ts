/// <reference path="Declarations/FileSystem.d.ts" />
/// <reference path="Configuration/AutoGeneratedFileWarning.ts" />
/// <reference path="Configuration/UIXConfiguration.ts" />
/// <reference path="Configuration/JestConfiguration.ts" />
/// <reference path="Configuration/TypeScriptConfiguration.ts" />
/// <reference path="Worker/CommandExecuter.ts" />
/// <reference path="Worker/FileMover.ts" />

//TODO:
//Build tools config for dev and release

namespace BuildTools{
    const args = process.argv;
    args.splice(0, 2);


    export const publish = checkArgsForArg("--publish");
    export const singleBuild = publish || checkArgsForArg("--build");

    export const fs = <FileSystem> require("fs");
    export const configPath = fs.realpathSync("..", {encoding: "utf8"}) + "/BuildTools.config.json";
    export const autoGeneratedFileWarning = Configuration.autoGeneratedFileWarning();

    export const directoryPaths = {
        src: fs.realpathSync("../..", {encoding: "utf8"}) + "/",
        typeScript: fs.realpathSync("../../TypeScript", {encoding: "utf8"}) + "/",
        scss: fs.realpathSync("../../Scss", {encoding: "utf8"}) + "/",
        output: fs.realpathSync("../../../" , {encoding: "utf8"}) + "/" + (publish ? "publish" : "build") + "/",
        content: fs.realpathSync("Content", {encoding: "utf8"}) + "/"
    }

    export let buildToolsConfiguration:Configuration.BuildToolsConfiguration;

    const activeCommandExecuter:Worker.CommandExecuter[] = [];
    const activeFileMover:Worker.FileMover[] = [];

    const postCSSPlugins = [
        "cssnano",
        "postcss-cssnext"
    ];

    type StateMachineState = "checkForActiveCommandExecuter"|"commandExecuterFinished"|"runPostCSS"|"waitForPostCSS"|"stopFileMover"|"waitForFileMover"|"fileMoverFinished";

    let errorOccurredDuringBuild = false;


    function main(){
        buildToolsConfiguration = Configuration.BuildToolsConfiguration.loadConfiguration(configPath);
        if(publish){
            buildToolsConfiguration.buildInRelease = true;
        }

        writeUIXConfiguration();
        writeJestConfiguration();

        fs.mkdirSync(directoryPaths.output, {recursive: true });
        console.log("Output directory is: " + directoryPaths.output);

        if(Configuration.BuildToolsConfiguration.getBuildMode(buildToolsConfiguration).copyDefaultContent){
            console.log("Copying default content . . .");
            copyDefaultContent();
        }

        if(singleBuild){
            console.log("Starting single build" + (publish ? " in publish mode" : "") + " . . .");
        }else{
            console.log("Starting in watch mode . . .");
        }
        console.log();

        const additionalVersions:Configuration.ESVersion[] = [
            //Configuration.ESVersion.ES2016,
            //Configuration.ESVersion.ES2020
        ];

        addTypeScriptCompilerTask("UIX", Configuration.BuildTarget.Browser, additionalVersions);
        addTypeScriptCompilerTask("UIX.ServiceWorker", Configuration.BuildTarget.ServiceWorker, []);
        addTypeScriptCompilerTask("UIX.AjaxWorker", Configuration.BuildTarget.WebWorker, additionalVersions);

        addSassTask();

        startFileMover();

        asyncStateMachine("checkForActiveCommandExecuter");
    }

    function asyncStateMachine(state:StateMachineState){
        switch(state){
            case "checkForActiveCommandExecuter":
                checkForActiveCommandExecuter(state, "commandExecuterFinished");
                break;

            case "commandExecuterFinished":
                if(errorOccurredDuringBuild){
                    process.exit(1);
                }else{
                    asyncStateMachine("runPostCSS");
                }
                break;

            case "runPostCSS":
                console.log();
                console.log("Starting PostCSS . . .");

                addPostCSSTask();
                asyncStateMachine("waitForPostCSS");
                break;

            case "waitForPostCSS":
                checkForActiveCommandExecuter(state, "stopFileMover");
                break;

            case "stopFileMover":
                if(errorOccurredDuringBuild){
                    process.exit(1);
                }else{
                    for(let i = 0; i < activeFileMover.length; i++){
                        activeFileMover[i].stop();
                    }
                    asyncStateMachine("waitForFileMover");
                }
                break;

            case "waitForFileMover":
                waitForFileMover();
                break;

            case "fileMoverFinished":
                break;
        }
    }

    function waitForFileMover(){
        for(let i = 0; i < activeFileMover.length; i++){
            if(!activeFileMover[i].runing){
                activeFileMover.splice(i--, 1);
            }
        }

        if(activeFileMover.length){
            setTimeout(() => asyncStateMachine("waitForFileMover"), 100);
        }else{
            asyncStateMachine("fileMoverFinished");
        }
    }

    function checkForActiveCommandExecuter(currentState:StateMachineState, nextState:StateMachineState){
        for(let i = 0; i < activeCommandExecuter.length; i++){
            const output = activeCommandExecuter[i].readLine();
            if(output){
                console.log((activeCommandExecuter[i].name ? activeCommandExecuter[i].name + ": ": "") + output);
            }
            if(!activeCommandExecuter[i].running){

                if(activeCommandExecuter[i].name){
                    if(activeCommandExecuter[i].exitCode === 0){
                        console.log(">>> '" + activeCommandExecuter[i].name + "' finished successfully <<<");
                    }else{
                        errorOccurredDuringBuild = true;
                        console.log(">>> error occurred in '" + activeCommandExecuter[i].name + "' (error code: " + activeCommandExecuter[i].exitCode + ") <<<");
                    }
                }

                activeCommandExecuter.splice(i--, 1);
            }
        }
        if(activeCommandExecuter.length){
            setTimeout(() => asyncStateMachine(currentState), 40);
        }else{
            asyncStateMachine(nextState);
        }
    }

    function writeUIXConfiguration(){
        const uixConfigurationPath = directoryPaths.typeScript + "UIX.Configuration.ts";
        
        const content = autoGeneratedFileWarning +
            "const YER_TOOLS_UIX_CONFIGURATION = \n" +
            JSON.stringify(new Configuration.UIXConfiguration(buildToolsConfiguration), undefined, 4) + ";";

        console.log("Writing 'UIX.Configuration.ts' to: " + uixConfigurationPath);        
        fs.writeFileSync(uixConfigurationPath, content, {encoding: "utf8"});
    }

    function writeJestConfiguration(){
        const jestConfigurationPath = directoryPaths.typeScript + "UnitTests/Jest.Configuration.js";
        
        const content = autoGeneratedFileWarning +
            "const JEST_CONFIGURATION = \n" +
            JSON.stringify(new Configuration.JestConfiguration(buildToolsConfiguration, directoryPaths.output), undefined, 4) + 
            ";\n" +
            "JEST_CONFIGURATION;";

        console.log("Writing 'Jest.Configuration.ts' to: " + jestConfigurationPath);        
        fs.writeFileSync(jestConfigurationPath, content, {encoding: "utf8"});
    }

    function copyDefaultContent(relativePath?:string){
        if(!relativePath){
            relativePath = "";
        }

        const srcDirectory = directoryPaths.content + relativePath;
        const destDirectory = directoryPaths.output + relativePath;

        fs.mkdirSync(destDirectory, {recursive: true});

        const children = fs.readdirSync(srcDirectory, {encoding: "utf8", withFileTypes: true});

        for(let i = 0; i < children.length; i++){
            if(children[i].isDirectory()){
                copyDefaultContent(relativePath + children[i].name + "/");
            }else if(children[i].isFile()){
                if(!fs.existsSync(destDirectory + children[i].name)){
                    fs.copyFileSync(srcDirectory + children[i].name, destDirectory + children[i].name);
                }
            }
        }
    }

    function checkArgsForArg(arg:string){
        for(let i = 0; i < args.length; i++){
            if(args[i] === arg){
                return true;
            }
        }
        return false;
    }

    function addTypeScriptCompilerTask(name:string, buildTarget:Configuration.BuildTarget, additionalVersions:Configuration.ESVersion[]){
        let outputDirectory = directoryPaths.output + (buildTarget === Configuration.BuildTarget.ServiceWorker ? "" : buildToolsConfiguration.serverFileStructure.javaScriptRootPath);
        fs.mkdirSync(outputDirectory, {recursive: true });
        outputDirectory = fs.realpathSync(outputDirectory, {encoding: "utf8"}) + "/";

        for(let i = -1; i < additionalVersions.length; i++){
            const configurationDirectory = directoryPaths.typeScript + (i === -1 ? name : ".tsconfig") + "/";
            fs.mkdirSync(configurationDirectory, {recursive: true });

            const versionName = i === -1 ? name : name + "." + Configuration.ESVersion[additionalVersions[i]];

            const typeScriptConfiguration = Configuration.TypeScriptConfiguration.fromBuildToolsConfig(
                buildToolsConfiguration, 
                outputDirectory + (i === -1 ? "" : Configuration.ESVersion[additionalVersions[i]] + "/") + versionName + ".js",
                buildTarget,
                i === -1 ? undefined : additionalVersions[i],
                i === -1 ? undefined : "./../" + name + "/**/*");
            
            const typeScriptConfigurationPath = configurationDirectory + (i === -1 ? "tsconfig" : versionName) + ".json";

            fs.writeFileSync(
                typeScriptConfigurationPath,
                autoGeneratedFileWarning + JSON.stringify(typeScriptConfiguration, undefined, 4),
                {encoding: "utf8"});
            
            const args = "--build" + (i === -1 ? "" : " " + versionName + ".json") + (singleBuild ? "" : " --watch");
            activeCommandExecuter.push(new Worker.CommandExecuter("tsc", args, configurationDirectory, "tsc(" + versionName + ")", i === -1 ? false : buildToolsConfiguration.muteAdditionalVersionsOutput));
        }
    }

    function addSassTask(){
        let outputDirectory = directoryPaths.output + buildToolsConfiguration.serverFileStructure.cssRootPath;
        fs.mkdirSync(outputDirectory, {recursive: true });
        outputDirectory = fs.realpathSync(outputDirectory, {encoding: "utf8"}) + "/";

        let args = directoryPaths.scss + ":" + outputDirectory;

        if(Configuration.BuildToolsConfiguration.getBuildMode(buildToolsConfiguration).sass.compress){
            args += " --style=compressed";
        }else{
            args += " --style=expanded";
        }

        if (Configuration.BuildToolsConfiguration.getBuildMode(buildToolsConfiguration).sass.sourceMap)
        {
            args += " --source-map --embed-sources";
        }else{
            args += " --no-source-map";
        }

        if (!singleBuild)
        {
            args += " --watch";
        }

        activeCommandExecuter.push(new Worker.CommandExecuter("sass", args, directoryPaths.src, "scss"));

    }

    function startFileMover(){
        if(Configuration.BuildToolsConfiguration.getBuildMode(buildToolsConfiguration).typeScript.sourceMap){
            activeFileMover.push(new Worker.FileMover(directoryPaths.output, directoryPaths.output + buildToolsConfiguration.serverFileStructure.sourceMapDirectory, new RegExp("^.*\\.js\\.map$")));
        }

        if(Configuration.BuildToolsConfiguration.getBuildMode(buildToolsConfiguration).typeScript.declaration){
            activeFileMover.push(new Worker.FileMover(directoryPaths.output, directoryPaths.output + buildToolsConfiguration.serverFileStructure.typeScriptDeclarationDirectory, new RegExp("^.*\\.d\\.ts$")));
        }
    }

    function addPostCSSTask(){
        let outputDirectory = directoryPaths.output + buildToolsConfiguration.serverFileStructure.cssRootPath;
        fs.mkdirSync(outputDirectory, {recursive: true });
        outputDirectory = fs.realpathSync(outputDirectory, {encoding: "utf8"}) + "/";

        let args = outputDirectory + "*.css --no-map";

        if (Configuration.BuildToolsConfiguration.getBuildMode(buildToolsConfiguration).sass.sourceMap)
        {
            args += " -m";
        }
        
        args += " -u";

        for(let i = 0; i < postCSSPlugins.length; i++){
            args += " " + postCSSPlugins[i];
        }

        args += " -r";

        activeCommandExecuter.push(new Worker.CommandExecuter("postcss", args, directoryPaths.src, "postCSS"));
    }

    main();
}