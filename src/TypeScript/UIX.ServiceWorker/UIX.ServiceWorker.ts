/// (UIX.Configuration.ts is generated by the provided buildtools)
/// <reference path="../UIX.Configuration.ts" />

/// <reference path="../UIX/Polyfill/Polyfills.ts" />
/// <reference path="../UIX/Core/Static/SharedData/Informations.ts" />
/// <reference path="../UIX/Libraries/Uri/Uri.ts" />
/// <reference path="TypeDefinitions/ServiceWorker.d.ts" />
/// <reference path="Helper/ResponseHelper.ts" />
/// <reference path="Helper/FileType.ts" />
/// <reference path="Helper/LocalStorage.ts" />

namespace UIX.ServiceWorker{
    const WEB_CACHE_NAME = "UIX.WebCache";
    const WEB_CACHE_TIMESTAMP_NAME = "UIX.WebCacheTimestamp";
    const DATA_CACHE_NAME = "UIX.DataCache";
    const MAX_REQUEST_LOADING_TIME = 250;
    const MAX_CACHE_AGE = 1000 * 60 * 60 * 24;

    export const webCacheTimestamp = new Helper.LocalStorage(WEB_CACHE_TIMESTAMP_NAME);
    export const dataCache = new Helper.LocalStorage(DATA_CACHE_NAME);
    export const serviceWorkerUri = Libraries.Uri.current.withRelative(new Libraries.Uri("/" + YER_TOOLS_UIX_CONFIGURATION.fileSystem.fileName.serviceWorker)); 

    function clearCache(){
        caches.delete(WEB_CACHE_NAME);
        caches.delete(WEB_CACHE_TIMESTAMP_NAME);
        caches.delete(DATA_CACHE_NAME);
    }

    function respondWithSpecial(requestUri:Libraries.Uri):Promise<Response>|null{
        if(requestUri.query){
            let containsKeyword = false;

            let parts = requestUri.query.split('&');
            for(let i = 0; i < parts.length; i++){
                if(parts[i] === "UIX-Clear-Cache=true"){
                    clearCache();
                    break;
                }else if(parts[i] === "UIX-Service-Worker=true"){
                    containsKeyword = true;
                    break;
                }
            }

            if(containsKeyword && requestUri.getFullPath() === serviceWorkerUri.getFullPath()){
                
            }
        }
        return null;

    }

    function canBeCached(uri:Libraries.Uri){
        
        return true;
    } 

    function fetchRequest(request:Request, requestUri:Libraries.Uri){
        return new Promise<Response>(async (resolve, reject) => {
            if(Libraries.Uri.current.isSameRoot(requestUri)){
                let now = new Date();
                let lastCacheTime:Date|undefined;
                {
                    let lastCacheTimeString = await webCacheTimestamp.get(requestUri.toString());
                    if(lastCacheTimeString){
                        try{
                            let date = new Date(lastCacheTimeString);
                            if(!isNaN(date.getTime())){
                                lastCacheTime = date;
                            }
                        }catch(error){}
                    }
                }

                let createNoCacheRequest = !lastCacheTime || (now.getTime() - lastCacheTime.getTime() > MAX_CACHE_AGE); 
                if(!createNoCacheRequest){
                    let fileType = Helper.FileType.get(requestUri);
                    if(fileType === Helper.FileType.FileType.UIXWebpage){
                        createNoCacheRequest = true;
                    }
                }

                if(createNoCacheRequest){
                    let noCacheUri = requestUri.addQuery("UIX-No-Cache", new Date().getTime().toString());
                    request = new Request(noCacheUri.toString());
                    webCacheTimestamp.set(requestUri.toString(), new Date().toISOString());
                }
            }else if(!webCacheTimestamp.has(requestUri.toString())){
                webCacheTimestamp.set(requestUri.toString(), new Date().toISOString());
            }

            fetch(request).then(response => resolve(response)).catch(reason => reject(reason));
        });
    }

    async function fetchAndCache(request:Request, requestUri:Libraries.Uri, lastCachedResponse:Response|undefined){
        try{
            let response = await fetchRequest(request, requestUri);

            let cache = await caches.open(WEB_CACHE_NAME);

            let responseClone = response.clone();
            if(lastCachedResponse){
                let equal = await Helper.ResponseHelper.equals(lastCachedResponse, responseClone);
                if(!equal){
                    cache.put(request, response.clone());
                }
            }else{
                cache.put(request, responseClone);
            }

            return response;
        }catch(error){
            return lastCachedResponse;
        }
    }

    function onInstall(event:InstallEvent){
        self.skipWaiting();

        event.waitUntil(new Promise(async resolve =>{
            let webCache = await caches.open(WEB_CACHE_NAME);

            let requests = await webCache.keys();
            
            let fetchUrls:string[] = [];
            let fetchUris:Libraries.Uri[] = [];
            let fetchUrlsSet = new Set<string>();

            for(let i = 0; i < requests.length; i++){
                let uri = new Libraries.Uri(requests[i].url);
                let fileType = Helper.FileType.get(uri);

                if(Helper.FileType.isPartOfUIX(fileType)){
                    if(fileType === Helper.FileType.FileType.StartPage){
                        if(!fetchUrlsSet.has("/")){
                            fetchUrlsSet.add("/")
                            fetchUrls.push("/");
                            fetchUris.push(uri);
                        }
                    }else{
                        let fullPath = uri.getFullPath();
                        if(!fetchUrlsSet.has(fullPath)){
                            fetchUrlsSet.add(fullPath)
                            fetchUrls.push(fullPath);
                            fetchUris.push(uri)
                        }
                    }
                }
            }

            if(!fetchUrlsSet.has("/")){
                fetchUrls.push("/");
                fetchUris.push(Libraries.Uri.current.withRelative(new Libraries.Uri("/")));
            }

            await caches.delete(WEB_CACHE_NAME);
            await webCacheTimestamp.clear();

            let promises:Promise<Response|undefined>[] = [];
            for(let i = 0; i < fetchUrls.length; i++){
                promises.push(fetchAndCache(new Request(fetchUrls[i]), fetchUris[i], undefined));
            }

            await Promise.all(promises);

            resolve();
        }));
    }

    function onFetch(event:FetchEvent){
        let uri = new Libraries.Uri(event.request.url);

        let shouldRespondWithSpecial = respondWithSpecial(uri);
        if(shouldRespondWithSpecial){
            event.respondWith(shouldRespondWithSpecial);
        }else if(canBeCached(uri)){
            event.respondWith(new Promise(async resolve => {
                let cachedResponse = await caches.open(WEB_CACHE_NAME).then(cache => cache.match(event.request, {ignoreSearch: false}));
                let fetchPromise = fetchAndCache(event.request, uri, cachedResponse?.clone());
                let timeoutHandle:number|null = null;
                if(cachedResponse){
                    timeoutHandle = setTimeout(()=>{
                        resolve(cachedResponse);
                    }, MAX_REQUEST_LOADING_TIME);
                }
                let fetchedResult = await fetchPromise;
                if(timeoutHandle !== null){
                    clearTimeout(timeoutHandle);
                }
                resolve(fetchedResult || cachedResponse);
            }));
        }else{
            event.respondWith(fetchRequest(event.request, uri));
        }
    }

    function onActivate(event:ActivateEvent){
        self.skipWaiting();

        event.waitUntil(
            caches.keys().then((keys) => {
              return Promise.all(keys.map((key) => {
                if (key !== WEB_CACHE_NAME && key !== WEB_CACHE_TIMESTAMP_NAME && key !== DATA_CACHE_NAME) {
                  return caches.delete(key);
                }
                return null;
              })).then(async () => {
                    if((<any>self).serviceWorker.state === "activating"){
                        try{
                            await self.clients.claim();
                        }catch(error){}
                    }
                    return null;
                });
            })
        );
    }
    
    if(!Core.Static.SharedData.Informations.isInBrowserContext){
        self.addEventListener("install", (event:any) => onInstall(event));
        self.addEventListener("fetch", (event:any) => onFetch(event));
        self.addEventListener("activate", (event:any) => onActivate(event));
        self.addEventListener("message", (event) => console.log(event));
    }
}